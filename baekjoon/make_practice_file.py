#!/usr/bin/env python3
"""
make_practice_file.py

- 기본 입력 파일: problems.txt
- 텍스트 파일에 'Day 1', 'Day 2' 같은 섹션 헤더와 그 아래 문제 목록(쉼표로 구분 등)이 있으면,
  각 Day별 디렉터리를 만들고 문제별 .py 파일을 생성합니다.
- 숫자(예: 2557)는 "2557.py"로 생성.
- 숫자가 아닌 문제명(프로그래머스)은 안전한 파일명으로 변환하여 생성(예: 완주하지_못한_선수.py).
- 이미 존재하는 파일이 있으면 중복 방지로 suffix를 붙입니다.
"""

import argparse
import os
import re
import sys
from pathlib import Path
from typing import Dict, List, Tuple

# -----------------------
# 설정: 템플릿 (원하시면 수정)
# -----------------------
PY_TEMPLATE = """#!/usr/bin/env python3
# -*- coding: utf-8 -*-
\"\"\"
Problem: {orig}
Source: {source}
Generated by make_practice_file.py
\"\"\"

import sys
from collections import deque, Counter, defaultdict
from heapq import heappush, heappop
from itertools import accumulate
from bisect import bisect_left, bisect_right
from math import gcd

input = sys.stdin.readline

def solve():
    # TODO: implement solution for: {orig}
    pass

if __name__ == '__main__':
    solve()
"""

# -----------------------
# 유틸: 안전한 파일명 생성
# -----------------------
def slugify(name: str) -> str:
    """
    파일명으로 안전한 형태로 변환.
    한글/영문/숫자와 '_'만 남기고 나머지는 '_'로 바꾼다.
    여러 '_'는 하나로 축소.
    """
    # strip surrounding spaces
    s = name.strip()
    # replace parentheses contents (optional): keep the main name but remove parentheses content for filenames
    s = re.sub(r'\(.*?\)', '', s).strip()
    # replace spaces and punctuation with underscore, allow Korean chars
    s = re.sub(r'[^0-9A-Za-z가-힣]+', '_', s)
    s = re.sub(r'_{2,}', '_', s)
    s = s.strip('_')
    if not s:
        s = 'problem'
    return s

# -----------------------
# 파싱 로직
# -----------------------
DAY_HEADER_RE = re.compile(r'^\s*Day\s*([0-9]+)', re.IGNORECASE)

def parse_sections(lines: List[str]) -> Dict[int, List[str]]:
    """
    텍스트 파일을 읽어 Day별로 문제 항목 목록을 반환.
    각 항목은 원문 스트링(예: '2557', '10871(필터)', '완주하지 못한 선수') 형태로 저장.
    """
    sections: Dict[int, List[str]] = {}
    current_day = None
    for raw in lines:
        line = raw.strip()
        if not line:
            continue
        # Day header detection
        m = DAY_HEADER_RE.match(line)
        if m:
            current_day = int(m.group(1))
            sections.setdefault(current_day, [])
            continue
        if current_day is None:
            # skip lines before first Day header
            continue
        # split line by commas (',') and also handle lines with parentheses containing commas? we assume simple commas
        parts = [p.strip() for p in re.split(r',|\t|·|•', line) if p.strip()]
        # also sometimes entries are space-separated phrases; keep them as single entries if no commas present
        sections[current_day].extend(parts)
    return sections

# -----------------------
# 파일 생성 로직
# -----------------------
def ensure_unique_filepath(path: Path) -> Path:
    """같은 파일명이 있으면 suffix 붙여서 유니크하게 반환"""
    if not path.exists():
        return path
    stem = path.stem
    suffix = path.suffix
    i = 1
    while True:
        new_path = path.with_name(f"{stem}_{i}{suffix}")
        if not new_path.exists():
            return new_path
        i += 1

def choose_filename(item: str) -> Tuple[str, str]:
    """
    item 문자열에서 숫자 코드가 있으면 (filename, source='BOJ')로 숫자 사용.
    숫자가 없으면 슬러그화하여 (filename, source='Programmers/Named') 반환.
    """
    # look for leading number
    m = re.search(r'(\d{3,5})', item)  # Baekjoon 번호는 보통 3~5자리
    if m:
        num = m.group(1)
        filename = f"{num}.py"
        source = "Baekjoon"
    else:
        slug = slugify(item)
        filename = f"{slug}.py"
        source = "Programmers/Named"
    return filename, source

def create_files(base_dir: Path, sections: Dict[int, List[str]]):
    created = []
    for day, items in sorted(sections.items()):
        day_dir = base_dir / f"Day{day}"
        day_dir.mkdir(parents=True, exist_ok=True)
        for raw_item in items:
            # ignore purely descriptive lines (e.g., "목표: ...") by heuristic: if contains ':' and no problem-like tokens, skip
            if ':' in raw_item and not re.search(r'\d|[가-힣]|[A-Za-z]', raw_item):
                continue
            # small heuristic: skip lines that look like notes (starting with '목표' or '보너스:' etc) only if they don't contain problem tokens
            if re.match(r'^(목표|보너스|예:|예시|예)$', raw_item.strip()):
                continue
            # split out embedded parenthetical notations and also split items that may contain multiple problems joined by '/'
            # but we had already split by commas earlier
            candidate = raw_item.strip()
            if not candidate:
                continue
            filename, source = choose_filename(candidate)
            filepath = day_dir / filename
            filepath = ensure_unique_filepath(filepath)
            # write template
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(PY_TEMPLATE.format(orig=candidate.replace('\n',' '), source=source))
            created.append((day, candidate, str(filepath)))
    # also create an index file
    index_path = base_dir / "created_index.txt"
    with open(index_path, 'w', encoding='utf-8') as idx:
        idx.write("Created files by make_practice_file.py\n\n")
        for day, item, path in created:
            idx.write(f"Day{day}\t{item}\t{path}\n")
    return created

# -----------------------
# 메인
# -----------------------
def main():
    parser = argparse.ArgumentParser(description="Create Day directories and problem .py files from a problems text file.")
    parser.add_argument('--input', '-i', default='problems.txt', help='Input text file with Day sections (default: problems.txt)')
    parser.add_argument('--out', '-o', default='.', help='Base output directory (default: current dir)')
    args = parser.parse_args()

    input_path = Path(args.input)
    if not input_path.exists():
        print(f"[ERROR] Input file not found: {input_path}", file=sys.stderr)
        sys.exit(1)

    text = input_path.read_text(encoding='utf-8')
    lines = text.splitlines()
    sections = parse_sections(lines)
    if not sections:
        print("[WARN] No Day sections found in input. Make sure your file contains lines like 'Day 1', 'Day 2' ...", file=sys.stderr)

    base_dir = Path(args.out)
    created = create_files(base_dir, sections)

    print(f"[DONE] Created {len(created)} files under {base_dir.resolve()}")
    print(f"[INFO] See {base_dir / 'created_index.txt'} for list")

if __name__ == '__main__':
    main()
